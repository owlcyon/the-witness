# Backend Implementation Guide

This guide explains how to take the frontend mockup designed here and build the functional backend in a new Replit instance.

## 1. Setup & Migration

1.  **Create New Instance**: Start a new Replit project (Node.js or Python).
2.  **Copy Frontend**:
    *   Copy the entire `client/` folder.
    *   Copy `vite.config.ts`, `tailwind.config.ts` (or `client/src/index.css` theme config), `postcss.config.js`.
    *   Copy `shared/` folder (if any schema definitions exist).
3.  **Install Dependencies**:
    *   Run `npm install` to get React, Vite, Tailwind, etc.
    *   Install backend specific deps (e.g., `pg`, `drizzle-orm` for Node; `fastapi`, `sqlalchemy` for Python).

## 2. Connecting Frontend & Backend

The frontend is pre-wired to make API requests to relative paths (e.g., `/api/v1/status`). You do not need to configure CORS if you serve the frontend from the same origin (standard Replit pattern).

### How it works:
*   **Frontend**: `client/src/lib/queryClient.ts` has an `apiRequest` function.
*   **Backend**: You must implement the routes in `server/routes.ts` (Node) or `main.py` (Python).

### Step-by-Step Wiring:

1.  **Open `server/routes.ts`** (or equivalent).
2.  **Create Endpoints** matching the `BACKEND_SPEC.md`.
    *   Example:
        ```typescript
        app.get("/api/v1/status", (req, res) => {
          res.json({
            system: "ONLINE",
            cpu_load: 12,
            gpu_active: true
          });
        });
        ```
3.  **WebSockets**:
    *   The frontend expects a WS connection for `/ws/stream`.
    *   Implement a WebSocket server (e.g., using `ws` library in Node or `FastAPI` websockets).
    *   Push JSON updates matching the `MemeEvent` interface.

## 3. Data Storage Strategy

For "The Witness", you need a hybrid storage approach:

1.  **PostgreSQL (Neon)**:
    *   Use for **Structured Data**: Users, Config, Graph Nodes, Edges.
    *   Use **Drizzle ORM** (Node) to define schemas in `shared/schema.ts`.
    *   *Why?* Relational integrity is crucial for the Knowledge Graph metadata.

2.  **Vector Store (pgvector)**:
    *   Enable `pgvector` extension on your Postgres instance.
    *   Store embeddings (BERT outputs) here for similarity search (Cosine Similarity).

3.  **Redis (Optional but Recommended)**:
    *   Use for **Task Queues** (Celery/BullMQ).
    *   Use for **Pub/Sub** to broadcast meme events to WebSockets.

## 4. Testing (Localhost)

In Replit, "Localhost" is the Dev Server.

1.  **Run Command**: `npm run dev` (or the "Run" button).
    *   This starts the Backend Server (Port 5000).
    *   Vite starts and proxies requests to the Backend.
2.  **Verify**:
    *   Open the Webview.
    *   Check the "System" tab -> "API Keys" to ensure configs are saving.
    *   Watch the "Meme Stream" -> If it's empty, your WebSocket isn't pushing data yet.

## 5. Autonomy Loop Implementation

To make it "Autonomous":

1.  **Cron Jobs / Schedulers**:
    *   Use `node-cron` or `APScheduler` (Python) to trigger the `crawl()` function every X minutes.
2.  **Agent Logic**:
    *   In your crawl loop, check `queue.length`.
    *   If empty, call your `Orchestrator` agent (LLM) to generate new seeds based on the `Graph` topology.
    *   "Deep Back Loop": Query the Graph for high-centrality nodes -> Convert to Search Queries -> Enqueue.

---

**Next Steps**:
Switch to the Backend Tab/Instance, paste the `BACKEND_SPEC.md`, and start coding `server/routes.ts`!
